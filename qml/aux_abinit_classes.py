# Everything related to convenient handling of ab initio data.

# Internal format for processing AOs.
orb_ang_mom={"s" : 0, "p" : 1, "d" : 2, "f" : 3, "g" : 4, "h" : 5, "i" : 6}

class AO:
    def __init__(self, ao_label, atom_id=None):
        if atom_id is None:
            info=ao_label.split()
            ao_type_large=info[-1]
            if len(info) == 3:
                self.atom_id=int(info[0])
            else:
                # Must be one of those weird labels generated by pyscf.tools.molden.load.
                for char_id, char in enumerate(info[0]):
                    if char.isalpha():
                        self.atom_id=int(info[0][:char_id])
                        break
        else:
            self.atom_id=atom_id
            ao_type_large=ao_label
        for char_id, char in enumerate(ao_type_large):
            if char.isalpha():
                self.ao_type=ao_type_large[:char_id+1]
                self.orientation=ao_type_large[char_id+1:]
                self.angular=orb_ang_mom[char]
                break
    def __str__(self):
        return self.__repr__()
    def __repr__(self):
        return ":atom_id:"+str(self.atom_id)+":ao_type:"+self.ao_type+":ang_momentum:"+str(self.angular)+":orientation:"+self.orientation

def potentially_dependent(ao1, ao2):
    return ((ao1.atom_id==ao2.atom_id) and (ao1.ao_type==ao2.ao_type))

def generate_ao_arr(mol):
    return [AO(ao_label) for ao_label in mol.ao_labels()]

# Contains the same data as a pySCF Mean Field (MF) object.
class Pseudo_MF:
    def __init__(self, e_tot=None, mo_coeff=None, mo_occ=None, mo_energy=None):
        self.e_tot=e_tot
        self.mo_coeff=mo_coeff
        self.mo_occ=mo_occ
        self.mo_energy=mo_energy
